/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.21.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Timestamp, Uint64, Collections, Metadata, Binary, CollectionConfig, CollectionInfo, MetadataInfo, TokenInfo, MintMsg, QueryMsg, MigrateMsg, ResponseWrapperForString, ResponseWrapperForCollectionInfo, ResponseWrapperForArrayOfCollectionsResponse, CollectionsResponse, Addr, ResponseWrapperForConfig, Config, ResponseWrapperForArrayOfUint32, ResponseWrapperForArrayOfString } from "./MintModule.types";
export interface MintModuleReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ResponseWrapperForConfig>;
  collectionAddress: () => Promise<ResponseWrapperForString>;
  collectionInfo: ({
    collectionId
  }: {
    collectionId: number;
  }) => Promise<ResponseWrapperForCollectionInfo>;
  operators: () => Promise<ResponseWrapperForArrayOfString>;
  linkedCollections: ({
    collectionId
  }: {
    collectionId: number;
  }) => Promise<ResponseWrapperForArrayOfUint32>;
  collections: ({
    blacklist,
    limit,
    startAfter
  }: {
    blacklist: boolean;
    limit?: number;
    startAfter?: number;
  }) => Promise<ResponseWrapperForArrayOfCollectionsResponse>;
}
export class MintModuleQueryClient implements MintModuleReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.collectionAddress = this.collectionAddress.bind(this);
    this.collectionInfo = this.collectionInfo.bind(this);
    this.operators = this.operators.bind(this);
    this.linkedCollections = this.linkedCollections.bind(this);
    this.collections = this.collections.bind(this);
  }

  config = async (): Promise<ResponseWrapperForConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  collectionAddress = async (): Promise<ResponseWrapperForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_address: {}
    });
  };
  collectionInfo = async ({
    collectionId
  }: {
    collectionId: number;
  }): Promise<ResponseWrapperForCollectionInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_info: {
        collection_id: collectionId
      }
    });
  };
  operators = async (): Promise<ResponseWrapperForArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      operators: {}
    });
  };
  linkedCollections = async ({
    collectionId
  }: {
    collectionId: number;
  }): Promise<ResponseWrapperForArrayOfUint32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      linked_collections: {
        collection_id: collectionId
      }
    });
  };
  collections = async ({
    blacklist,
    limit,
    startAfter
  }: {
    blacklist: boolean;
    limit?: number;
    startAfter?: number;
  }): Promise<ResponseWrapperForArrayOfCollectionsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collections: {
        blacklist,
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface MintModuleInterface extends MintModuleReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createCollection: ({
    codeId,
    collectionConfig,
    collectionInfo,
    linkedCollections,
    metadataInfo,
    tokenInfo
  }: {
    codeId: number;
    collectionConfig: CollectionConfig;
    collectionInfo: CollectionInfo;
    linkedCollections?: number[];
    metadataInfo: MetadataInfo;
    tokenInfo: TokenInfo;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updatePublicCollectionCreation: ({
    publicCollectionCreation
  }: {
    publicCollectionCreation: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateMintLock: ({
    lock
  }: {
    lock: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  mint: ({
    collectionId,
    metadataId
  }: {
    collectionId: number;
    metadataId?: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  adminMint: ({
    collectionId,
    metadataId,
    recipient
  }: {
    collectionId: number;
    metadataId?: number;
    recipient: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  permissionMint: ({
    mintMsg,
    permissionMsg
  }: {
    mintMsg: MintMsg;
    permissionMsg: Binary;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateOperators: ({
    addrs
  }: {
    addrs: string[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateLinkedCollections: ({
    collectionId,
    linkedCollections
  }: {
    collectionId: number;
    linkedCollections: number[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  whitelistCollection: ({
    collectionId
  }: {
    collectionId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  blacklistCollection: ({
    collectionId
  }: {
    collectionId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MintModuleClient extends MintModuleQueryClient implements MintModuleInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createCollection = this.createCollection.bind(this);
    this.updatePublicCollectionCreation = this.updatePublicCollectionCreation.bind(this);
    this.updateMintLock = this.updateMintLock.bind(this);
    this.mint = this.mint.bind(this);
    this.adminMint = this.adminMint.bind(this);
    this.permissionMint = this.permissionMint.bind(this);
    this.updateOperators = this.updateOperators.bind(this);
    this.updateLinkedCollections = this.updateLinkedCollections.bind(this);
    this.whitelistCollection = this.whitelistCollection.bind(this);
    this.blacklistCollection = this.blacklistCollection.bind(this);
  }

  createCollection = async ({
    codeId,
    collectionConfig,
    collectionInfo,
    linkedCollections,
    metadataInfo,
    tokenInfo
  }: {
    codeId: number;
    collectionConfig: CollectionConfig;
    collectionInfo: CollectionInfo;
    linkedCollections?: number[];
    metadataInfo: MetadataInfo;
    tokenInfo: TokenInfo;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_collection: {
        code_id: codeId,
        collection_config: collectionConfig,
        collection_info: collectionInfo,
        linked_collections: linkedCollections,
        metadata_info: metadataInfo,
        token_info: tokenInfo
      }
    }, fee, memo, funds);
  };
  updatePublicCollectionCreation = async ({
    publicCollectionCreation
  }: {
    publicCollectionCreation: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_public_collection_creation: {
        public_collection_creation: publicCollectionCreation
      }
    }, fee, memo, funds);
  };
  updateMintLock = async ({
    lock
  }: {
    lock: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mint_lock: {
        lock
      }
    }, fee, memo, funds);
  };
  mint = async ({
    collectionId,
    metadataId
  }: {
    collectionId: number;
    metadataId?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      mint: {
        collection_id: collectionId,
        metadata_id: metadataId
      }
    }, fee, memo, funds);
  };
  adminMint = async ({
    collectionId,
    metadataId,
    recipient
  }: {
    collectionId: number;
    metadataId?: number;
    recipient: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_mint: {
        collection_id: collectionId,
        metadata_id: metadataId,
        recipient
      }
    }, fee, memo, funds);
  };
  permissionMint = async ({
    mintMsg,
    permissionMsg
  }: {
    mintMsg: MintMsg;
    permissionMsg: Binary;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      permission_mint: {
        mint_msg: mintMsg,
        permission_msg: permissionMsg
      }
    }, fee, memo, funds);
  };
  updateOperators = async ({
    addrs
  }: {
    addrs: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_operators: {
        addrs
      }
    }, fee, memo, funds);
  };
  updateLinkedCollections = async ({
    collectionId,
    linkedCollections
  }: {
    collectionId: number;
    linkedCollections: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_linked_collections: {
        collection_id: collectionId,
        linked_collections: linkedCollections
      }
    }, fee, memo, funds);
  };
  whitelistCollection = async ({
    collectionId
  }: {
    collectionId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      whitelist_collection: {
        collection_id: collectionId
      }
    }, fee, memo, funds);
  };
  blacklistCollection = async ({
    collectionId
  }: {
    collectionId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      blacklist_collection: {
        collection_id: collectionId
      }
    }, fee, memo, funds);
  };
}