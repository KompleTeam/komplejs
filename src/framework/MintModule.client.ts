/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.21.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Binary, InstantiateMsg, ExecuteMsg, Timestamp, Uint64, Collections, Metadata, Uint128, CollectionConfig, CollectionInfo, CollectionFundInfo, MetadataInfo, TokenInfo, MintMsg, Cw20ReceiveMsg, QueryMsg, MigrateMsg, ResponseWrapperForString, ResponseWrapperForCollectionInfo, ResponseWrapperForArrayOfCollectionsResponse, CollectionsResponse, Addr, ResponseWrapperForConfig, Config, ResponseWrapperForArrayOfString, ResponseWrapperForArrayOfUint32, ResponseWrapperForBoolean } from "./MintModule.types";
export interface MintModuleReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ResponseWrapperForConfig>;
  collectionAddress: ({
    collectionId
  }: {
    collectionId: number;
  }) => Promise<ResponseWrapperForString>;
  collectionInfo: ({
    collectionId
  }: {
    collectionId: number;
  }) => Promise<ResponseWrapperForCollectionInfo>;
  operators: () => Promise<ResponseWrapperForArrayOfString>;
  linkedCollections: ({
    collectionId
  }: {
    collectionId: number;
  }) => Promise<ResponseWrapperForArrayOfUint32>;
  collections: ({
    blacklist,
    limit,
    startAfter
  }: {
    blacklist: boolean;
    limit?: number;
    startAfter?: number;
  }) => Promise<ResponseWrapperForArrayOfCollectionsResponse>;
  creators: () => Promise<ResponseWrapperForArrayOfString>;
  mintLock: ({
    collectionId
  }: {
    collectionId: number;
  }) => Promise<ResponseWrapperForBoolean>;
}
export class MintModuleQueryClient implements MintModuleReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.collectionAddress = this.collectionAddress.bind(this);
    this.collectionInfo = this.collectionInfo.bind(this);
    this.operators = this.operators.bind(this);
    this.linkedCollections = this.linkedCollections.bind(this);
    this.collections = this.collections.bind(this);
    this.creators = this.creators.bind(this);
    this.mintLock = this.mintLock.bind(this);
  }

  config = async (): Promise<ResponseWrapperForConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  collectionAddress = async ({
    collectionId
  }: {
    collectionId: number;
  }): Promise<ResponseWrapperForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_address: {
        collection_id: collectionId
      }
    });
  };
  collectionInfo = async ({
    collectionId
  }: {
    collectionId: number;
  }): Promise<ResponseWrapperForCollectionInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_info: {
        collection_id: collectionId
      }
    });
  };
  operators = async (): Promise<ResponseWrapperForArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      operators: {}
    });
  };
  linkedCollections = async ({
    collectionId
  }: {
    collectionId: number;
  }): Promise<ResponseWrapperForArrayOfUint32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      linked_collections: {
        collection_id: collectionId
      }
    });
  };
  collections = async ({
    blacklist,
    limit,
    startAfter
  }: {
    blacklist: boolean;
    limit?: number;
    startAfter?: number;
  }): Promise<ResponseWrapperForArrayOfCollectionsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collections: {
        blacklist,
        limit,
        start_after: startAfter
      }
    });
  };
  creators = async (): Promise<ResponseWrapperForArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      creators: {}
    });
  };
  mintLock = async ({
    collectionId
  }: {
    collectionId: number;
  }): Promise<ResponseWrapperForBoolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      mint_lock: {
        collection_id: collectionId
      }
    });
  };
}
export interface MintModuleInterface extends MintModuleReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createCollection: ({
    codeId,
    collectionConfig,
    collectionInfo,
    fundInfo,
    linkedCollections,
    metadataInfo,
    tokenInfo
  }: {
    codeId: number;
    collectionConfig: CollectionConfig;
    collectionInfo: CollectionInfo;
    fundInfo: CollectionFundInfo;
    linkedCollections?: number[];
    metadataInfo: MetadataInfo;
    tokenInfo: TokenInfo;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updatePublicCollectionCreation: ({
    publicCollectionCreation
  }: {
    publicCollectionCreation: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateCollectionMintLock: ({
    collectionId,
    lock
  }: {
    collectionId: number;
    lock: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  mint: ({
    collectionId,
    metadataId
  }: {
    collectionId: number;
    metadataId?: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  adminMint: ({
    collectionId,
    metadataId,
    recipient
  }: {
    collectionId: number;
    metadataId?: number;
    recipient: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  permissionMint: ({
    mintMsg,
    permissionMsg
  }: {
    mintMsg: MintMsg;
    permissionMsg: Binary;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateOperators: ({
    addrs
  }: {
    addrs: string[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateLinkedCollections: ({
    collectionId,
    linkedCollections
  }: {
    collectionId: number;
    linkedCollections: number[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateCollectionStatus: ({
    collectionId,
    isBlacklist
  }: {
    collectionId: number;
    isBlacklist: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  lockExecute: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateCreators: ({
    addrs
  }: {
    addrs: string[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MintModuleClient extends MintModuleQueryClient implements MintModuleInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createCollection = this.createCollection.bind(this);
    this.updatePublicCollectionCreation = this.updatePublicCollectionCreation.bind(this);
    this.updateCollectionMintLock = this.updateCollectionMintLock.bind(this);
    this.mint = this.mint.bind(this);
    this.adminMint = this.adminMint.bind(this);
    this.permissionMint = this.permissionMint.bind(this);
    this.updateOperators = this.updateOperators.bind(this);
    this.updateLinkedCollections = this.updateLinkedCollections.bind(this);
    this.updateCollectionStatus = this.updateCollectionStatus.bind(this);
    this.lockExecute = this.lockExecute.bind(this);
    this.updateCreators = this.updateCreators.bind(this);
    this.receive = this.receive.bind(this);
  }

  createCollection = async ({
    codeId,
    collectionConfig,
    collectionInfo,
    fundInfo,
    linkedCollections,
    metadataInfo,
    tokenInfo
  }: {
    codeId: number;
    collectionConfig: CollectionConfig;
    collectionInfo: CollectionInfo;
    fundInfo: CollectionFundInfo;
    linkedCollections?: number[];
    metadataInfo: MetadataInfo;
    tokenInfo: TokenInfo;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_collection: {
        code_id: codeId,
        collection_config: collectionConfig,
        collection_info: collectionInfo,
        fund_info: fundInfo,
        linked_collections: linkedCollections,
        metadata_info: metadataInfo,
        token_info: tokenInfo
      }
    }, fee, memo, funds);
  };
  updatePublicCollectionCreation = async ({
    publicCollectionCreation
  }: {
    publicCollectionCreation: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_public_collection_creation: {
        public_collection_creation: publicCollectionCreation
      }
    }, fee, memo, funds);
  };
  updateCollectionMintLock = async ({
    collectionId,
    lock
  }: {
    collectionId: number;
    lock: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_collection_mint_lock: {
        collection_id: collectionId,
        lock
      }
    }, fee, memo, funds);
  };
  mint = async ({
    collectionId,
    metadataId
  }: {
    collectionId: number;
    metadataId?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      mint: {
        collection_id: collectionId,
        metadata_id: metadataId
      }
    }, fee, memo, funds);
  };
  adminMint = async ({
    collectionId,
    metadataId,
    recipient
  }: {
    collectionId: number;
    metadataId?: number;
    recipient: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_mint: {
        collection_id: collectionId,
        metadata_id: metadataId,
        recipient
      }
    }, fee, memo, funds);
  };
  permissionMint = async ({
    mintMsg,
    permissionMsg
  }: {
    mintMsg: MintMsg;
    permissionMsg: Binary;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      permission_mint: {
        mint_msg: mintMsg,
        permission_msg: permissionMsg
      }
    }, fee, memo, funds);
  };
  updateOperators = async ({
    addrs
  }: {
    addrs: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_operators: {
        addrs
      }
    }, fee, memo, funds);
  };
  updateLinkedCollections = async ({
    collectionId,
    linkedCollections
  }: {
    collectionId: number;
    linkedCollections: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_linked_collections: {
        collection_id: collectionId,
        linked_collections: linkedCollections
      }
    }, fee, memo, funds);
  };
  updateCollectionStatus = async ({
    collectionId,
    isBlacklist
  }: {
    collectionId: number;
    isBlacklist: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_collection_status: {
        collection_id: collectionId,
        is_blacklist: isBlacklist
      }
    }, fee, memo, funds);
  };
  lockExecute = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      lock_execute: {}
    }, fee, memo, funds);
  };
  updateCreators = async ({
    addrs
  }: {
    addrs: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_creators: {
        addrs
      }
    }, fee, memo, funds);
  };
  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, fee, memo, funds);
  };
}