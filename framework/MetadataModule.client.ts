/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.21.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Metadata, InstantiateMsg, ExecuteMsg, Trait, MetaInfo, QueryMsg, MigrateMsg, Addr, ResponseWrapperForConfig, Config, ResponseWrapperForMetadataResponse, MetadataResponse, ResponseWrapperForArrayOfMetadataResponse, ResponseWrapperForArrayOfString, ResponseWrapperForMetadata } from "./MetadataModule.types";
export interface MetadataModuleReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ResponseWrapperForConfig>;
  rawMetadata: ({
    metadataId
  }: {
    metadataId: number;
  }) => Promise<ResponseWrapperForMetadata>;
  metadata: ({
    tokenId
  }: {
    tokenId: number;
  }) => Promise<ResponseWrapperForMetadataResponse>;
  rawMetadatas: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<ResponseWrapperForArrayOfMetadataResponse>;
  metadatas: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<ResponseWrapperForArrayOfMetadataResponse>;
  operators: () => Promise<ResponseWrapperForArrayOfString>;
}
export class MetadataModuleQueryClient implements MetadataModuleReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.rawMetadata = this.rawMetadata.bind(this);
    this.metadata = this.metadata.bind(this);
    this.rawMetadatas = this.rawMetadatas.bind(this);
    this.metadatas = this.metadatas.bind(this);
    this.operators = this.operators.bind(this);
  }

  config = async (): Promise<ResponseWrapperForConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  rawMetadata = async ({
    metadataId
  }: {
    metadataId: number;
  }): Promise<ResponseWrapperForMetadata> => {
    return this.client.queryContractSmart(this.contractAddress, {
      raw_metadata: {
        metadata_id: metadataId
      }
    });
  };
  metadata = async ({
    tokenId
  }: {
    tokenId: number;
  }): Promise<ResponseWrapperForMetadataResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      metadata: {
        token_id: tokenId
      }
    });
  };
  rawMetadatas = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<ResponseWrapperForArrayOfMetadataResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      raw_metadatas: {
        limit,
        start_after: startAfter
      }
    });
  };
  metadatas = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<ResponseWrapperForArrayOfMetadataResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      metadatas: {
        limit,
        start_after: startAfter
      }
    });
  };
  operators = async (): Promise<ResponseWrapperForArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      operators: {}
    });
  };
}
export interface MetadataModuleInterface extends MetadataModuleReadOnlyInterface {
  contractAddress: string;
  sender: string;
  addMetadata: ({
    attributes,
    metaInfo
  }: {
    attributes: Trait[];
    metaInfo: MetaInfo;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  linkMetadata: ({
    metadataId,
    tokenId
  }: {
    metadataId?: number;
    tokenId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  unlinkMetadata: ({
    tokenId
  }: {
    tokenId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateMetaInfo: ({
    id,
    metaInfo,
    rawMetadata
  }: {
    id: number;
    metaInfo: MetaInfo;
    rawMetadata: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addAttribute: ({
    attribute,
    id,
    rawMetadata
  }: {
    attribute: Trait;
    id: number;
    rawMetadata: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateAttribute: ({
    attribute,
    id,
    rawMetadata
  }: {
    attribute: Trait;
    id: number;
    rawMetadata: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removeAttribute: ({
    id,
    rawMetadata,
    traitType
  }: {
    id: number;
    rawMetadata: boolean;
    traitType: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateOperators: ({
    addrs
  }: {
    addrs: string[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MetadataModuleClient extends MetadataModuleQueryClient implements MetadataModuleInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.addMetadata = this.addMetadata.bind(this);
    this.linkMetadata = this.linkMetadata.bind(this);
    this.unlinkMetadata = this.unlinkMetadata.bind(this);
    this.updateMetaInfo = this.updateMetaInfo.bind(this);
    this.addAttribute = this.addAttribute.bind(this);
    this.updateAttribute = this.updateAttribute.bind(this);
    this.removeAttribute = this.removeAttribute.bind(this);
    this.updateOperators = this.updateOperators.bind(this);
  }

  addMetadata = async ({
    attributes,
    metaInfo
  }: {
    attributes: Trait[];
    metaInfo: MetaInfo;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_metadata: {
        attributes,
        meta_info: metaInfo
      }
    }, fee, memo, funds);
  };
  linkMetadata = async ({
    metadataId,
    tokenId
  }: {
    metadataId?: number;
    tokenId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      link_metadata: {
        metadata_id: metadataId,
        token_id: tokenId
      }
    }, fee, memo, funds);
  };
  unlinkMetadata = async ({
    tokenId
  }: {
    tokenId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unlink_metadata: {
        token_id: tokenId
      }
    }, fee, memo, funds);
  };
  updateMetaInfo = async ({
    id,
    metaInfo,
    rawMetadata
  }: {
    id: number;
    metaInfo: MetaInfo;
    rawMetadata: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_meta_info: {
        id,
        meta_info: metaInfo,
        raw_metadata: rawMetadata
      }
    }, fee, memo, funds);
  };
  addAttribute = async ({
    attribute,
    id,
    rawMetadata
  }: {
    attribute: Trait;
    id: number;
    rawMetadata: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_attribute: {
        attribute,
        id,
        raw_metadata: rawMetadata
      }
    }, fee, memo, funds);
  };
  updateAttribute = async ({
    attribute,
    id,
    rawMetadata
  }: {
    attribute: Trait;
    id: number;
    rawMetadata: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_attribute: {
        attribute,
        id,
        raw_metadata: rawMetadata
      }
    }, fee, memo, funds);
  };
  removeAttribute = async ({
    id,
    rawMetadata,
    traitType
  }: {
    id: number;
    rawMetadata: boolean;
    traitType: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_attribute: {
        id,
        raw_metadata: rawMetadata,
        trait_type: traitType
      }
    }, fee, memo, funds);
  };
  updateOperators = async ({
    addrs
  }: {
    addrs: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_operators: {
        addrs
      }
    }, fee, memo, funds);
  };
}